// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.3.4.5

#pragma once
#include "winrt/Windows.Foundation.Collections.h"
#include "winrt/test_component.h"
namespace winrt::test_component::implementation
{
    template <typename D, typename... I>
    struct __declspec(empty_bases) Class_base : implements<D, test_component::Class, I...>
    {
        using base_type = Class_base;
        using class_type = test_component::Class;
        using implements_type = typename Class_base::implements_type;
        using implements_type::implements_type;
        
        hstring GetRuntimeClassName() const
        {
            return L"test_component.Class";
        }
    };
}
namespace winrt::test_component::factory_implementation
{
    template <typename D, typename T, typename... I>
    struct __declspec(empty_bases) ClassT : implements<D, Windows::Foundation::IActivationFactory, test_component::IClassFactory, test_component::IClassStatics, I...>
    {
        using instance_type = test_component::Class;

        hstring GetRuntimeClassName() const
        {
            return L"test_component.Class";
        }
        auto ActivateInstance() const
        {
            return make<T>();
        }
        auto CreateInstance(hstring const& name)
        {
            return make<T>(name);
        }
        auto CreateInstance2(Windows::Foundation::Collections::IIterable<hstring> const& arg, int32_t dummy1)
        {
            return make<T>(arg, dummy1);
        }
        auto CreateInstance3(Windows::Foundation::Collections::IIterable<Windows::Foundation::Collections::IKeyValuePair<hstring, hstring>> const& arg, int32_t dummy1, int32_t dummy2)
        {
            return make<T>(arg, dummy1, dummy2);
        }
        auto CreateInstance4(Windows::Foundation::Collections::IMap<hstring, hstring> const& arg, int32_t dummy1, int32_t dummy2, int32_t dummy3)
        {
            return make<T>(arg, dummy1, dummy2, dummy3);
        }
        auto CreateInstance5(Windows::Foundation::Collections::IMapView<hstring, hstring> const& arg, int32_t dummy1, int32_t dummy2, int32_t dummy3, int32_t dummy4)
        {
            return make<T>(arg, dummy1, dummy2, dummy3, dummy4);
        }
        auto CreateInstance6(Windows::Foundation::Collections::IVector<hstring> const& arg, int32_t dummy1, int32_t dummy2, int32_t dummy3, int32_t dummy4, int32_t dummy5)
        {
            return make<T>(arg, dummy1, dummy2, dummy3, dummy4, dummy5);
        }
        auto CreateInstance7(Windows::Foundation::Collections::IVectorView<hstring> const& arg, int32_t dummy1, int32_t dummy2, int32_t dummy3, int32_t dummy4, int32_t dummy5, int32_t dummy6)
        {
            return make<T>(arg, dummy1, dummy2, dummy3, dummy4, dummy5, dummy6);
        }
        auto StaticTest()
        {
            return T::StaticTest();
        }
        auto StaticTestReturn()
        {
            return T::StaticTestReturn();
        }
        auto StaticProperty()
        {
            return T::StaticProperty();
        }
        auto InIterable(Windows::Foundation::Collections::IIterable<hstring> const& value)
        {
            return T::InIterable(value);
        }
        auto InIterablePair(Windows::Foundation::Collections::IIterable<Windows::Foundation::Collections::IKeyValuePair<hstring, hstring>> const& value)
        {
            return T::InIterablePair(value);
        }
        auto InAsyncIterable(Windows::Foundation::Collections::IIterable<hstring> const& value)
        {
            return T::InAsyncIterable(value);
        }
        auto InAsyncIterablePair(Windows::Foundation::Collections::IIterable<Windows::Foundation::Collections::IKeyValuePair<hstring, hstring>> const& value)
        {
            return T::InAsyncIterablePair(value);
        }
        auto InMap(Windows::Foundation::Collections::IMap<hstring, hstring> const& value)
        {
            return T::InMap(value);
        }
        auto InMapView(Windows::Foundation::Collections::IMapView<hstring, hstring> const& value)
        {
            return T::InMapView(value);
        }
        auto InAsyncMapView(Windows::Foundation::Collections::IMapView<hstring, hstring> const& value)
        {
            return T::InAsyncMapView(value);
        }
        auto InVector(Windows::Foundation::Collections::IVector<hstring> const& value)
        {
            return T::InVector(value);
        }
        auto InVectorView(Windows::Foundation::Collections::IVectorView<hstring> const& value)
        {
            return T::InVectorView(value);
        }
        auto InAsyncVectorView(Windows::Foundation::Collections::IVectorView<hstring> const& value)
        {
            return T::InAsyncVectorView(value);
        }
    };
}

#if defined(WINRT_FORCE_INCLUDE_CLASS_XAML_G_H) || __has_include("Class.xaml.g.h")
#include "Class.xaml.g.h"
#else

namespace winrt::test_component::implementation
{
    template <typename D, typename... I>
    using ClassT = Class_base<D, I...>;
}

#endif
