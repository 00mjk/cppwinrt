// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.3.4.5

#ifndef WINRT_test_component_0_H
#define WINRT_test_component_0_H
WINRT_EXPORT namespace winrt::Windows::Foundation
{
    struct Deferral;
    struct EventRegistrationToken;
    struct IAsyncAction;
    struct IStringable;
    template <typename TSender, typename TResult> struct TypedEventHandler;
}
WINRT_EXPORT namespace winrt::Windows::Foundation::Collections
{
    template <typename T> struct IIterable;
    template <typename K, typename V> struct IKeyValuePair;
    template <typename K, typename V> struct IMapView;
    template <typename K, typename V> struct IMap;
    template <typename T> struct IVectorView;
    template <typename T> struct IVector;
}
WINRT_EXPORT namespace winrt::test_component
{
    enum class Signed : int32_t
    {
        First = -1,
        Second = 0,
        Third = 1,
    };
    enum class Unsigned : uint32_t
    {
        First = 0,
        Second = 0x1,
        Third = 0x2,
    };
    struct IClass;
    struct IClassFactory;
    struct IClassStatics;
    struct IDeferrableEventArgs;
    struct ISimple;
    struct Class;
    struct DeferrableEventArgs;
    struct Simple;
    struct Struct;
}
namespace winrt::impl
{
    template <> struct category<test_component::IClass>{ using type = interface_category; };
    template <> struct category<test_component::IClassFactory>{ using type = interface_category; };
    template <> struct category<test_component::IClassStatics>{ using type = interface_category; };
    template <> struct category<test_component::IDeferrableEventArgs>{ using type = interface_category; };
    template <> struct category<test_component::ISimple>{ using type = interface_category; };
    template <> struct category<test_component::Class>{ using type = class_category; };
    template <> struct category<test_component::DeferrableEventArgs>{ using type = class_category; };
    template <> struct category<test_component::Simple>{ using type = class_category; };
    template <> struct category<test_component::Signed>{ using type = enum_category; };
    template <> struct category<test_component::Unsigned>{ using type = enum_category; };
    template <> struct category<test_component::Struct>{ using type = struct_category<hstring, hstring>; };
    template <> inline constexpr auto& name_v<test_component::Class>{ L"test_component.Class" };
    template <> inline constexpr auto& name_v<test_component::DeferrableEventArgs>{ L"test_component.DeferrableEventArgs" };
    template <> inline constexpr auto& name_v<test_component::Simple>{ L"test_component.Simple" };
    template <> inline constexpr auto& name_v<test_component::Signed>{ L"test_component.Signed" };
    template <> inline constexpr auto& name_v<test_component::Unsigned>{ L"test_component.Unsigned" };
    template <> inline constexpr auto& name_v<test_component::Struct>{ L"test_component.Struct" };
#ifndef WINRT_LEAN_AND_MEAN
    template <> inline constexpr auto& name_v<test_component::IClass>{ L"test_component.IClass" };
    template <> inline constexpr auto& name_v<test_component::IClassFactory>{ L"test_component.IClassFactory" };
    template <> inline constexpr auto& name_v<test_component::IClassStatics>{ L"test_component.IClassStatics" };
    template <> inline constexpr auto& name_v<test_component::IDeferrableEventArgs>{ L"test_component.IDeferrableEventArgs" };
    template <> inline constexpr auto& name_v<test_component::ISimple>{ L"test_component.ISimple" };
#endif
    template <> inline constexpr guid guid_v<test_component::IClass>{ 0x97222DCE,0x2B32,0x5EC4,{ 0xA4,0x82,0x71,0xDD,0xCE,0xCF,0x28,0x41 } };
    template <> inline constexpr guid guid_v<test_component::IClassFactory>{ 0x5FFAAB03,0x2FCD,0x5BAD,{ 0x8B,0x13,0x1E,0xD9,0x7A,0x18,0xFE,0xEB } };
    template <> inline constexpr guid guid_v<test_component::IClassStatics>{ 0x8E50AEC2,0x403C,0x5005,{ 0x9A,0xC4,0xCE,0x66,0xE6,0xF8,0x64,0x41 } };
    template <> inline constexpr guid guid_v<test_component::IDeferrableEventArgs>{ 0xDA7B0340,0x93E0,0x5D49,{ 0xA7,0xF3,0x0F,0xCA,0x6E,0x90,0x02,0x3C } };
    template <> inline constexpr guid guid_v<test_component::ISimple>{ 0xC4CD142D,0x3E22,0x5DA8,{ 0x9A,0x26,0x50,0xB0,0x04,0x79,0x4D,0xE2 } };
    template <> struct default_interface<test_component::Class>{ using type = test_component::IClass; };
    template <> struct default_interface<test_component::DeferrableEventArgs>{ using type = test_component::IDeferrableEventArgs; };
    template <> struct default_interface<test_component::Simple>{ using type = test_component::ISimple; };
    template <> struct abi<test_component::IClass>
    {
        struct __declspec(novtable) type : inspectable_abi
        {
            virtual int32_t __stdcall Fail(bool) noexcept = 0;
            virtual int32_t __stdcall InInt32(int32_t, void**) noexcept = 0;
            virtual int32_t __stdcall InString(void*, void**) noexcept = 0;
            virtual int32_t __stdcall InObject(void*, void**) noexcept = 0;
            virtual int32_t __stdcall InStringable(void*, void**) noexcept = 0;
            virtual int32_t __stdcall InStruct(struct struct_test_component_Struct, void**) noexcept = 0;
            virtual int32_t __stdcall InStructRef(struct struct_test_component_Struct const&, void**) noexcept = 0;
            virtual int32_t __stdcall InEnum(int32_t, void**) noexcept = 0;
            virtual int32_t __stdcall OutInt32(int32_t*) noexcept = 0;
            virtual int32_t __stdcall OutString(void**) noexcept = 0;
            virtual int32_t __stdcall OutObject(void**) noexcept = 0;
            virtual int32_t __stdcall OutStringable(void**) noexcept = 0;
            virtual int32_t __stdcall OutStruct(struct struct_test_component_Struct*) noexcept = 0;
            virtual int32_t __stdcall OutEnum(int32_t*) noexcept = 0;
            virtual int32_t __stdcall ReturnInt32(int32_t*) noexcept = 0;
            virtual int32_t __stdcall ReturnString(void**) noexcept = 0;
            virtual int32_t __stdcall ReturnObject(void**) noexcept = 0;
            virtual int32_t __stdcall ReturnStringable(void**) noexcept = 0;
            virtual int32_t __stdcall ReturnStruct(struct struct_test_component_Struct*) noexcept = 0;
            virtual int32_t __stdcall ReturnEnum(int32_t*) noexcept = 0;
            virtual int32_t __stdcall InInt32Array(uint32_t, int32_t*, void**) noexcept = 0;
            virtual int32_t __stdcall InStringArray(uint32_t, void**, void**) noexcept = 0;
            virtual int32_t __stdcall InObjectArray(uint32_t, void**, void**) noexcept = 0;
            virtual int32_t __stdcall InStringableArray(uint32_t, void**, void**) noexcept = 0;
            virtual int32_t __stdcall InStructArray(uint32_t, struct struct_test_component_Struct*, void**) noexcept = 0;
            virtual int32_t __stdcall InEnumArray(uint32_t, int32_t*, void**) noexcept = 0;
            virtual int32_t __stdcall OutInt32Array(uint32_t*, int32_t**) noexcept = 0;
            virtual int32_t __stdcall OutStringArray(uint32_t*, void***) noexcept = 0;
            virtual int32_t __stdcall OutObjectArray(uint32_t*, void***) noexcept = 0;
            virtual int32_t __stdcall OutStringableArray(uint32_t*, void***) noexcept = 0;
            virtual int32_t __stdcall OutStructArray(uint32_t*, struct struct_test_component_Struct**) noexcept = 0;
            virtual int32_t __stdcall OutEnumArray(uint32_t*, int32_t**) noexcept = 0;
            virtual int32_t __stdcall RefInt32Array(uint32_t, int32_t*) noexcept = 0;
            virtual int32_t __stdcall RefStringArray(uint32_t, void**) noexcept = 0;
            virtual int32_t __stdcall RefObjectArray(uint32_t, void**) noexcept = 0;
            virtual int32_t __stdcall RefStringableArray(uint32_t, void**) noexcept = 0;
            virtual int32_t __stdcall RefStructArray(uint32_t, struct struct_test_component_Struct*) noexcept = 0;
            virtual int32_t __stdcall RefEnumArray(uint32_t, int32_t*) noexcept = 0;
            virtual int32_t __stdcall ReturnInt32Array(uint32_t* __resultSize, int32_t**) noexcept = 0;
            virtual int32_t __stdcall ReturnStringArray(uint32_t* __resultSize, void***) noexcept = 0;
            virtual int32_t __stdcall ReturnObjectArray(uint32_t* __resultSize, void***) noexcept = 0;
            virtual int32_t __stdcall ReturnStringableArray(uint32_t* __resultSize, void***) noexcept = 0;
            virtual int32_t __stdcall ReturnStructArray(uint32_t* __resultSize, struct struct_test_component_Struct**) noexcept = 0;
            virtual int32_t __stdcall ReturnEnumArray(uint32_t* __resultSize, int32_t**) noexcept = 0;
            virtual int32_t __stdcall NoexceptVoid() noexcept = 0;
            virtual int32_t __stdcall NoexceptInt32(int32_t*) noexcept = 0;
            virtual int32_t __stdcall NoexceptString(void**) noexcept = 0;
            virtual int32_t __stdcall add_DeferrableEvent(void*, winrt::event_token*) noexcept = 0;
            virtual int32_t __stdcall remove_DeferrableEvent(winrt::event_token) noexcept = 0;
            virtual int32_t __stdcall RaiseDeferrableEventAsync(void**) noexcept = 0;
        };
    };
    template <> struct abi<test_component::IClassFactory>
    {
        struct __declspec(novtable) type : inspectable_abi
        {
            virtual int32_t __stdcall CreateInstance(void*, void**) noexcept = 0;
            virtual int32_t __stdcall CreateInstance2(void*, int32_t, void**) noexcept = 0;
            virtual int32_t __stdcall CreateInstance3(void*, int32_t, int32_t, void**) noexcept = 0;
            virtual int32_t __stdcall CreateInstance4(void*, int32_t, int32_t, int32_t, void**) noexcept = 0;
            virtual int32_t __stdcall CreateInstance5(void*, int32_t, int32_t, int32_t, int32_t, void**) noexcept = 0;
            virtual int32_t __stdcall CreateInstance6(void*, int32_t, int32_t, int32_t, int32_t, int32_t, void**) noexcept = 0;
            virtual int32_t __stdcall CreateInstance7(void*, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, void**) noexcept = 0;
        };
    };
    template <> struct abi<test_component::IClassStatics>
    {
        struct __declspec(novtable) type : inspectable_abi
        {
            virtual int32_t __stdcall StaticTest() noexcept = 0;
            virtual int32_t __stdcall StaticTestReturn(int32_t*) noexcept = 0;
            virtual int32_t __stdcall get_StaticProperty(int32_t*) noexcept = 0;
            virtual int32_t __stdcall InIterable(void*, void**) noexcept = 0;
            virtual int32_t __stdcall InIterablePair(void*, void**) noexcept = 0;
            virtual int32_t __stdcall InAsyncIterable(void*, void**) noexcept = 0;
            virtual int32_t __stdcall InAsyncIterablePair(void*, void**) noexcept = 0;
            virtual int32_t __stdcall InMap(void*, void**) noexcept = 0;
            virtual int32_t __stdcall InMapView(void*, void**) noexcept = 0;
            virtual int32_t __stdcall InAsyncMapView(void*, void**) noexcept = 0;
            virtual int32_t __stdcall InVector(void*, void**) noexcept = 0;
            virtual int32_t __stdcall InVectorView(void*, void**) noexcept = 0;
            virtual int32_t __stdcall InAsyncVectorView(void*, void**) noexcept = 0;
        };
    };
    template <> struct abi<test_component::IDeferrableEventArgs>
    {
        struct __declspec(novtable) type : inspectable_abi
        {
            virtual int32_t __stdcall GetDeferral(void**) noexcept = 0;
            virtual int32_t __stdcall IncrementCounter() noexcept = 0;
        };
    };
    template <> struct abi<test_component::ISimple>
    {
        struct __declspec(novtable) type : inspectable_abi
        {
            virtual int32_t __stdcall Method() noexcept = 0;
            virtual int32_t __stdcall Reference(int64_t, void**) noexcept = 0;
            virtual int32_t __stdcall Operation(int64_t, void**) noexcept = 0;
            virtual int32_t __stdcall Action(int64_t, void**) noexcept = 0;
            virtual int32_t __stdcall Object(int64_t, void**) noexcept = 0;
        };
    };
    template <typename D>
    struct consume_test_component_IClass
    {
        auto Fail(bool value) const;
        auto InInt32(int32_t value) const;
        auto InString(param::hstring const& value) const;
        auto InObject(Windows::Foundation::IInspectable const& value) const;
        auto InStringable(Windows::Foundation::IStringable const& value) const;
        auto InStruct(test_component::Struct const& value) const;
        auto InStructRef(test_component::Struct const& value) const;
        auto InEnum(test_component::Signed const& value) const;
        auto OutInt32(int32_t& value) const;
        auto OutString(hstring& value) const;
        auto OutObject(Windows::Foundation::IInspectable& value) const;
        auto OutStringable(Windows::Foundation::IStringable& value) const;
        auto OutStruct(test_component::Struct& value) const;
        auto OutEnum(test_component::Signed& value) const;
        auto ReturnInt32() const;
        auto ReturnString() const;
        auto ReturnObject() const;
        auto ReturnStringable() const;
        auto ReturnStruct() const;
        auto ReturnEnum() const;
        auto InInt32Array(array_view<int32_t const> value) const;
        auto InStringArray(array_view<hstring const> value) const;
        auto InObjectArray(array_view<Windows::Foundation::IInspectable const> value) const;
        auto InStringableArray(array_view<Windows::Foundation::IStringable const> value) const;
        auto InStructArray(array_view<test_component::Struct const> value) const;
        auto InEnumArray(array_view<test_component::Signed const> value) const;
        auto OutInt32Array(com_array<int32_t>& value) const;
        auto OutStringArray(com_array<hstring>& value) const;
        auto OutObjectArray(com_array<Windows::Foundation::IInspectable>& value) const;
        auto OutStringableArray(com_array<Windows::Foundation::IStringable>& value) const;
        auto OutStructArray(com_array<test_component::Struct>& value) const;
        auto OutEnumArray(com_array<test_component::Signed>& value) const;
        auto RefInt32Array(array_view<int32_t> value) const;
        auto RefStringArray(array_view<hstring> value) const;
        auto RefObjectArray(array_view<Windows::Foundation::IInspectable> value) const;
        auto RefStringableArray(array_view<Windows::Foundation::IStringable> value) const;
        auto RefStructArray(array_view<test_component::Struct> value) const;
        auto RefEnumArray(array_view<test_component::Signed> value) const;
        auto ReturnInt32Array() const;
        auto ReturnStringArray() const;
        auto ReturnObjectArray() const;
        auto ReturnStringableArray() const;
        auto ReturnStructArray() const;
        auto ReturnEnumArray() const;
        auto NoexceptVoid() const noexcept;
        auto NoexceptInt32() const noexcept;
        auto NoexceptString() const noexcept;
        auto DeferrableEvent(Windows::Foundation::TypedEventHandler<test_component::Class, test_component::DeferrableEventArgs> const& handler) const;
        using DeferrableEvent_revoker = impl::event_revoker<test_component::IClass, &impl::abi_t<test_component::IClass>::remove_DeferrableEvent>;
        [[nodiscard]] DeferrableEvent_revoker DeferrableEvent(auto_revoke_t, Windows::Foundation::TypedEventHandler<test_component::Class, test_component::DeferrableEventArgs> const& handler) const;
        auto DeferrableEvent(winrt::event_token const& token) const noexcept;
        auto RaiseDeferrableEventAsync() const;
    };
    template <> struct consume<test_component::IClass>
    {
        template <typename D> using type = consume_test_component_IClass<D>;
    };
    template <typename D>
    struct consume_test_component_IClassFactory
    {
        auto CreateInstance(param::hstring const& name) const;
        auto CreateInstance2(param::iterable<hstring> const& arg, int32_t dummy1) const;
        auto CreateInstance3(param::iterable<Windows::Foundation::Collections::IKeyValuePair<hstring, hstring>> const& arg, int32_t dummy1, int32_t dummy2) const;
        auto CreateInstance4(param::map<hstring, hstring> const& arg, int32_t dummy1, int32_t dummy2, int32_t dummy3) const;
        auto CreateInstance5(param::map_view<hstring, hstring> const& arg, int32_t dummy1, int32_t dummy2, int32_t dummy3, int32_t dummy4) const;
        auto CreateInstance6(param::vector<hstring> const& arg, int32_t dummy1, int32_t dummy2, int32_t dummy3, int32_t dummy4, int32_t dummy5) const;
        auto CreateInstance7(param::vector_view<hstring> const& arg, int32_t dummy1, int32_t dummy2, int32_t dummy3, int32_t dummy4, int32_t dummy5, int32_t dummy6) const;
    };
    template <> struct consume<test_component::IClassFactory>
    {
        template <typename D> using type = consume_test_component_IClassFactory<D>;
    };
    template <typename D>
    struct consume_test_component_IClassStatics
    {
        auto StaticTest() const;
        auto StaticTestReturn() const;
        [[nodiscard]] auto StaticProperty() const;
        auto InIterable(param::iterable<hstring> const& value) const;
        auto InIterablePair(param::iterable<Windows::Foundation::Collections::IKeyValuePair<hstring, hstring>> const& value) const;
        auto InAsyncIterable(param::async_iterable<hstring> const& value) const;
        auto InAsyncIterablePair(param::async_iterable<Windows::Foundation::Collections::IKeyValuePair<hstring, hstring>> const& value) const;
        auto InMap(param::map<hstring, hstring> const& value) const;
        auto InMapView(param::map_view<hstring, hstring> const& value) const;
        auto InAsyncMapView(param::async_map_view<hstring, hstring> const& value) const;
        auto InVector(param::vector<hstring> const& value) const;
        auto InVectorView(param::vector_view<hstring> const& value) const;
        auto InAsyncVectorView(param::async_vector_view<hstring> const& value) const;
    };
    template <> struct consume<test_component::IClassStatics>
    {
        template <typename D> using type = consume_test_component_IClassStatics<D>;
    };
    template <typename D>
    struct consume_test_component_IDeferrableEventArgs
    {
        auto GetDeferral() const;
        auto IncrementCounter() const;
    };
    template <> struct consume<test_component::IDeferrableEventArgs>
    {
        template <typename D> using type = consume_test_component_IDeferrableEventArgs<D>;
    };
    template <typename D>
    struct consume_test_component_ISimple
    {
        auto Method() const;
        auto Reference(Windows::Foundation::DateTime const& value) const;
        auto Operation(Windows::Foundation::DateTime const& value) const;
        auto Action(Windows::Foundation::DateTime const& value) const;
        auto Object(Windows::Foundation::DateTime const& value) const;
    };
    template <> struct consume<test_component::ISimple>
    {
        template <typename D> using type = consume_test_component_ISimple<D>;
    };
    struct struct_test_component_Struct
    {
        void* First;
        void* Second;
    };
    template <> struct abi<test_component::Struct>
    {
        using type = struct_test_component_Struct;
    };
}
#endif
