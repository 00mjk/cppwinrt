// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.3.4.5

#ifndef WINRT_test_component_Velocity_0_H
#define WINRT_test_component_Velocity_0_H
WINRT_EXPORT namespace winrt::test_component::Velocity
{
    struct IClass1;
    struct IClass2;
    struct IClass3;
    struct IClass4;
    struct IClass4Factory;
    struct IClass4Factory2;
    struct IClass4Statics;
    struct IClass4Statics2;
    struct IInterface1;
    struct IInterface2;
    struct Class1;
    struct Class2;
    struct Class3;
    struct Class4;
}
namespace winrt::impl
{
    template <> struct category<test_component::Velocity::IClass1>{ using type = interface_category; };
    template <> struct category<test_component::Velocity::IClass2>{ using type = interface_category; };
    template <> struct category<test_component::Velocity::IClass3>{ using type = interface_category; };
    template <> struct category<test_component::Velocity::IClass4>{ using type = interface_category; };
    template <> struct category<test_component::Velocity::IClass4Factory>{ using type = interface_category; };
    template <> struct category<test_component::Velocity::IClass4Factory2>{ using type = interface_category; };
    template <> struct category<test_component::Velocity::IClass4Statics>{ using type = interface_category; };
    template <> struct category<test_component::Velocity::IClass4Statics2>{ using type = interface_category; };
    template <> struct category<test_component::Velocity::IInterface1>{ using type = interface_category; };
    template <> struct category<test_component::Velocity::IInterface2>{ using type = interface_category; };
    template <> struct category<test_component::Velocity::Class1>{ using type = class_category; };
    template <> struct category<test_component::Velocity::Class2>{ using type = class_category; };
    template <> struct category<test_component::Velocity::Class3>{ using type = class_category; };
    template <> struct category<test_component::Velocity::Class4>{ using type = class_category; };
    template <> inline constexpr auto& name_v<test_component::Velocity::Class1>{ L"test_component.Velocity.Class1" };
    template <> inline constexpr auto& name_v<test_component::Velocity::Class2>{ L"test_component.Velocity.Class2" };
    template <> inline constexpr auto& name_v<test_component::Velocity::Class3>{ L"test_component.Velocity.Class3" };
    template <> inline constexpr auto& name_v<test_component::Velocity::Class4>{ L"test_component.Velocity.Class4" };
#ifndef WINRT_LEAN_AND_MEAN
    template <> inline constexpr auto& name_v<test_component::Velocity::IClass1>{ L"test_component.Velocity.IClass1" };
    template <> inline constexpr auto& name_v<test_component::Velocity::IClass2>{ L"test_component.Velocity.IClass2" };
    template <> inline constexpr auto& name_v<test_component::Velocity::IClass3>{ L"test_component.Velocity.IClass3" };
    template <> inline constexpr auto& name_v<test_component::Velocity::IClass4>{ L"test_component.Velocity.IClass4" };
    template <> inline constexpr auto& name_v<test_component::Velocity::IClass4Factory>{ L"test_component.Velocity.IClass4Factory" };
    template <> inline constexpr auto& name_v<test_component::Velocity::IClass4Factory2>{ L"test_component.Velocity.IClass4Factory2" };
    template <> inline constexpr auto& name_v<test_component::Velocity::IClass4Statics>{ L"test_component.Velocity.IClass4Statics" };
    template <> inline constexpr auto& name_v<test_component::Velocity::IClass4Statics2>{ L"test_component.Velocity.IClass4Statics2" };
    template <> inline constexpr auto& name_v<test_component::Velocity::IInterface1>{ L"test_component.Velocity.IInterface1" };
    template <> inline constexpr auto& name_v<test_component::Velocity::IInterface2>{ L"test_component.Velocity.IInterface2" };
#endif
    template <> inline constexpr guid guid_v<test_component::Velocity::IClass1>{ 0x1A345E87,0xEFE4,0x50B8,{ 0xA9,0x66,0xB8,0xD2,0xC5,0xCA,0x1F,0xCC } };
    template <> inline constexpr guid guid_v<test_component::Velocity::IClass2>{ 0x38CFC3BC,0x54D5,0x571B,{ 0x84,0x50,0x42,0xD9,0x7B,0x82,0x39,0x7B } };
    template <> inline constexpr guid guid_v<test_component::Velocity::IClass3>{ 0x892B7A9B,0x6613,0x5D28,{ 0x95,0xCF,0x3E,0x5F,0xAB,0xE8,0x2B,0x6C } };
    template <> inline constexpr guid guid_v<test_component::Velocity::IClass4>{ 0x0A080BFE,0x9EDA,0x5912,{ 0x8F,0xC0,0x28,0x46,0xBE,0xA8,0x60,0xB6 } };
    template <> inline constexpr guid guid_v<test_component::Velocity::IClass4Factory>{ 0x6DF97431,0x5034,0x5AC3,{ 0xB3,0x8B,0xC2,0xB7,0xF1,0x22,0x46,0x4B } };
    template <> inline constexpr guid guid_v<test_component::Velocity::IClass4Factory2>{ 0x19660F52,0x4A35,0x5E21,{ 0xAA,0x64,0x20,0xC5,0xAF,0xD0,0xD3,0x2F } };
    template <> inline constexpr guid guid_v<test_component::Velocity::IClass4Statics>{ 0xF789BEF6,0x6919,0x5B6F,{ 0x9C,0x77,0x51,0xCE,0x77,0xAD,0xF1,0x50 } };
    template <> inline constexpr guid guid_v<test_component::Velocity::IClass4Statics2>{ 0x0F3BB325,0x873A,0x5E31,{ 0xA8,0x70,0x78,0xC2,0xEF,0xA5,0xC8,0x32 } };
    template <> inline constexpr guid guid_v<test_component::Velocity::IInterface1>{ 0x8F9CEB8F,0x0DCD,0x542D,{ 0xB5,0x87,0xEE,0xC1,0xB0,0x1A,0x13,0xEC } };
    template <> inline constexpr guid guid_v<test_component::Velocity::IInterface2>{ 0xC9D50F83,0x68C5,0x55FA,{ 0x9B,0x86,0x83,0x95,0x09,0xE2,0x0D,0x44 } };
    template <> struct default_interface<test_component::Velocity::Class1>{ using type = test_component::Velocity::IClass1; };
    template <> struct default_interface<test_component::Velocity::Class2>{ using type = test_component::Velocity::IClass2; };
    template <> struct default_interface<test_component::Velocity::Class3>{ using type = test_component::Velocity::IClass3; };
    template <> struct default_interface<test_component::Velocity::Class4>{ using type = test_component::Velocity::IClass4; };
    template <> struct abi<test_component::Velocity::IClass1>
    {
        struct __declspec(novtable) type : inspectable_abi
        {
            virtual int32_t __stdcall Class1_Method() noexcept = 0;
        };
    };
    template <> struct abi<test_component::Velocity::IClass2>
    {
        struct __declspec(novtable) type : inspectable_abi
        {
            virtual int32_t __stdcall Class2_Method() noexcept = 0;
        };
    };
    template <> struct abi<test_component::Velocity::IClass3>
    {
        struct __declspec(novtable) type : inspectable_abi
        {
            virtual int32_t __stdcall Class3_Method() noexcept = 0;
        };
    };
    template <> struct abi<test_component::Velocity::IClass4>
    {
        struct __declspec(novtable) type : inspectable_abi
        {
            virtual int32_t __stdcall Class4_Method() noexcept = 0;
        };
    };
    template <> struct abi<test_component::Velocity::IClass4Factory>
    {
        struct __declspec(novtable) type : inspectable_abi
        {
            virtual int32_t __stdcall CreateInstance(int32_t, void**) noexcept = 0;
        };
    };
    template <> struct abi<test_component::Velocity::IClass4Factory2>
    {
        struct __declspec(novtable) type : inspectable_abi
        {
            virtual int32_t __stdcall CreateInstance(int32_t, int32_t, void**) noexcept = 0;
        };
    };
    template <> struct abi<test_component::Velocity::IClass4Statics>
    {
        struct __declspec(novtable) type : inspectable_abi
        {
            virtual int32_t __stdcall Class4_Static1() noexcept = 0;
        };
    };
    template <> struct abi<test_component::Velocity::IClass4Statics2>
    {
        struct __declspec(novtable) type : inspectable_abi
        {
            virtual int32_t __stdcall Class4_Static2() noexcept = 0;
        };
    };
    template <> struct abi<test_component::Velocity::IInterface1>
    {
        struct __declspec(novtable) type : inspectable_abi
        {
            virtual int32_t __stdcall IInterface1_Method() noexcept = 0;
        };
    };
    template <> struct abi<test_component::Velocity::IInterface2>
    {
        struct __declspec(novtable) type : inspectable_abi
        {
            virtual int32_t __stdcall IInterface2_Method() noexcept = 0;
        };
    };
    template <typename D>
    struct consume_test_component_Velocity_IClass1
    {
        auto Class1_Method() const;
    };
    template <> struct consume<test_component::Velocity::IClass1>
    {
        template <typename D> using type = consume_test_component_Velocity_IClass1<D>;
    };
    template <typename D>
    struct consume_test_component_Velocity_IClass2
    {
        auto Class2_Method() const;
    };
    template <> struct consume<test_component::Velocity::IClass2>
    {
        template <typename D> using type = consume_test_component_Velocity_IClass2<D>;
    };
    template <typename D>
    struct consume_test_component_Velocity_IClass3
    {
        auto Class3_Method() const;
    };
    template <> struct consume<test_component::Velocity::IClass3>
    {
        template <typename D> using type = consume_test_component_Velocity_IClass3<D>;
    };
    template <typename D>
    struct consume_test_component_Velocity_IClass4
    {
        auto Class4_Method() const;
    };
    template <> struct consume<test_component::Velocity::IClass4>
    {
        template <typename D> using type = consume_test_component_Velocity_IClass4<D>;
    };
    template <typename D>
    struct consume_test_component_Velocity_IClass4Factory
    {
        auto CreateInstance(int32_t one) const;
    };
    template <> struct consume<test_component::Velocity::IClass4Factory>
    {
        template <typename D> using type = consume_test_component_Velocity_IClass4Factory<D>;
    };
    template <typename D>
    struct consume_test_component_Velocity_IClass4Factory2
    {
        auto CreateInstance(int32_t one, int32_t two) const;
    };
    template <> struct consume<test_component::Velocity::IClass4Factory2>
    {
        template <typename D> using type = consume_test_component_Velocity_IClass4Factory2<D>;
    };
    template <typename D>
    struct consume_test_component_Velocity_IClass4Statics
    {
        auto Class4_Static1() const;
    };
    template <> struct consume<test_component::Velocity::IClass4Statics>
    {
        template <typename D> using type = consume_test_component_Velocity_IClass4Statics<D>;
    };
    template <typename D>
    struct consume_test_component_Velocity_IClass4Statics2
    {
        auto Class4_Static2() const;
    };
    template <> struct consume<test_component::Velocity::IClass4Statics2>
    {
        template <typename D> using type = consume_test_component_Velocity_IClass4Statics2<D>;
    };
    template <typename D>
    struct consume_test_component_Velocity_IInterface1
    {
        auto IInterface1_Method() const;
    };
    template <> struct consume<test_component::Velocity::IInterface1>
    {
        template <typename D> using type = consume_test_component_Velocity_IInterface1<D>;
    };
    template <typename D>
    struct consume_test_component_Velocity_IInterface2
    {
        auto IInterface2_Method() const;
    };
    template <> struct consume<test_component::Velocity::IInterface2>
    {
        template <typename D> using type = consume_test_component_Velocity_IInterface2<D>;
    };
}
#endif
