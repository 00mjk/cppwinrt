// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.3.4.5

#ifndef WINRT_test_component_H
#define WINRT_test_component_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.3.4.5"), "Mismatched C++/WinRT headers.");
#include "winrt/impl/Windows.Foundation.2.h"
#include "winrt/impl/Windows.Foundation.Collections.2.h"
#include "winrt/impl/test_component.2.h"
namespace winrt::impl
{
    template <typename D> auto consume_test_component_IClass<D>::Fail(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(test_component::IClass)->Fail(value));
    }
    template <typename D> auto consume_test_component_IClass<D>::InInt32(int32_t value) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(test_component::IClass)->InInt32(value, &result));
        return hstring{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_test_component_IClass<D>::InString(param::hstring const& value) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(test_component::IClass)->InString(*(void**)(&value), &result));
        return hstring{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_test_component_IClass<D>::InObject(Windows::Foundation::IInspectable const& value) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(test_component::IClass)->InObject(*(void**)(&value), &result));
        return hstring{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_test_component_IClass<D>::InStringable(Windows::Foundation::IStringable const& value) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(test_component::IClass)->InStringable(*(void**)(&value), &result));
        return hstring{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_test_component_IClass<D>::InStruct(test_component::Struct const& value) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(test_component::IClass)->InStruct(impl::bind_in(value), &result));
        return hstring{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_test_component_IClass<D>::InStructRef(test_component::Struct const& value) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(test_component::IClass)->InStructRef(impl::bind_in(value), &result));
        return hstring{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_test_component_IClass<D>::InEnum(test_component::Signed const& value) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(test_component::IClass)->InEnum(static_cast<int32_t>(value), &result));
        return hstring{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_test_component_IClass<D>::OutInt32(int32_t& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(test_component::IClass)->OutInt32(&value));
    }
    template <typename D> auto consume_test_component_IClass<D>::OutString(hstring& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(test_component::IClass)->OutString(impl::bind_out(value)));
    }
    template <typename D> auto consume_test_component_IClass<D>::OutObject(Windows::Foundation::IInspectable& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(test_component::IClass)->OutObject(impl::bind_out(value)));
    }
    template <typename D> auto consume_test_component_IClass<D>::OutStringable(Windows::Foundation::IStringable& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(test_component::IClass)->OutStringable(impl::bind_out(value)));
    }
    template <typename D> auto consume_test_component_IClass<D>::OutStruct(test_component::Struct& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(test_component::IClass)->OutStruct(impl::bind_out(value)));
    }
    template <typename D> auto consume_test_component_IClass<D>::OutEnum(test_component::Signed& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(test_component::IClass)->OutEnum(reinterpret_cast<int32_t*>(&value)));
    }
    template <typename D> auto consume_test_component_IClass<D>::ReturnInt32() const
    {
        int32_t result;
        check_hresult(WINRT_IMPL_SHIM(test_component::IClass)->ReturnInt32(&result));
        return result;
    }
    template <typename D> auto consume_test_component_IClass<D>::ReturnString() const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(test_component::IClass)->ReturnString(&result));
        return hstring{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_test_component_IClass<D>::ReturnObject() const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(test_component::IClass)->ReturnObject(&result));
        return Windows::Foundation::IInspectable{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_test_component_IClass<D>::ReturnStringable() const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(test_component::IClass)->ReturnStringable(&result));
        return Windows::Foundation::IStringable{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_test_component_IClass<D>::ReturnStruct() const
    {
        test_component::Struct result;
        check_hresult(WINRT_IMPL_SHIM(test_component::IClass)->ReturnStruct(put_abi(result)));
        return result;
    }
    template <typename D> auto consume_test_component_IClass<D>::ReturnEnum() const
    {
        test_component::Signed result;
        check_hresult(WINRT_IMPL_SHIM(test_component::IClass)->ReturnEnum(reinterpret_cast<int32_t*>(&result)));
        return result;
    }
    template <typename D> auto consume_test_component_IClass<D>::InInt32Array(array_view<int32_t const> value) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(test_component::IClass)->InInt32Array(value.size(), get_abi(value), &result));
        return hstring{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_test_component_IClass<D>::InStringArray(array_view<hstring const> value) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(test_component::IClass)->InStringArray(value.size(), get_abi(value), &result));
        return hstring{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_test_component_IClass<D>::InObjectArray(array_view<Windows::Foundation::IInspectable const> value) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(test_component::IClass)->InObjectArray(value.size(), get_abi(value), &result));
        return hstring{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_test_component_IClass<D>::InStringableArray(array_view<Windows::Foundation::IStringable const> value) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(test_component::IClass)->InStringableArray(value.size(), get_abi(value), &result));
        return hstring{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_test_component_IClass<D>::InStructArray(array_view<test_component::Struct const> value) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(test_component::IClass)->InStructArray(value.size(), get_abi(value), &result));
        return hstring{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_test_component_IClass<D>::InEnumArray(array_view<test_component::Signed const> value) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(test_component::IClass)->InEnumArray(value.size(), get_abi(value), &result));
        return hstring{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_test_component_IClass<D>::OutInt32Array(com_array<int32_t>& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(test_component::IClass)->OutInt32Array(impl::put_size_abi(value), put_abi(value)));
    }
    template <typename D> auto consume_test_component_IClass<D>::OutStringArray(com_array<hstring>& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(test_component::IClass)->OutStringArray(impl::put_size_abi(value), put_abi(value)));
    }
    template <typename D> auto consume_test_component_IClass<D>::OutObjectArray(com_array<Windows::Foundation::IInspectable>& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(test_component::IClass)->OutObjectArray(impl::put_size_abi(value), put_abi(value)));
    }
    template <typename D> auto consume_test_component_IClass<D>::OutStringableArray(com_array<Windows::Foundation::IStringable>& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(test_component::IClass)->OutStringableArray(impl::put_size_abi(value), put_abi(value)));
    }
    template <typename D> auto consume_test_component_IClass<D>::OutStructArray(com_array<test_component::Struct>& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(test_component::IClass)->OutStructArray(impl::put_size_abi(value), put_abi(value)));
    }
    template <typename D> auto consume_test_component_IClass<D>::OutEnumArray(com_array<test_component::Signed>& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(test_component::IClass)->OutEnumArray(impl::put_size_abi(value), put_abi(value)));
    }
    template <typename D> auto consume_test_component_IClass<D>::RefInt32Array(array_view<int32_t> value) const
    {
        check_hresult(WINRT_IMPL_SHIM(test_component::IClass)->RefInt32Array(value.size(), put_abi(value)));
    }
    template <typename D> auto consume_test_component_IClass<D>::RefStringArray(array_view<hstring> value) const
    {
        check_hresult(WINRT_IMPL_SHIM(test_component::IClass)->RefStringArray(value.size(), put_abi(value)));
    }
    template <typename D> auto consume_test_component_IClass<D>::RefObjectArray(array_view<Windows::Foundation::IInspectable> value) const
    {
        check_hresult(WINRT_IMPL_SHIM(test_component::IClass)->RefObjectArray(value.size(), put_abi(value)));
    }
    template <typename D> auto consume_test_component_IClass<D>::RefStringableArray(array_view<Windows::Foundation::IStringable> value) const
    {
        check_hresult(WINRT_IMPL_SHIM(test_component::IClass)->RefStringableArray(value.size(), put_abi(value)));
    }
    template <typename D> auto consume_test_component_IClass<D>::RefStructArray(array_view<test_component::Struct> value) const
    {
        check_hresult(WINRT_IMPL_SHIM(test_component::IClass)->RefStructArray(value.size(), put_abi(value)));
    }
    template <typename D> auto consume_test_component_IClass<D>::RefEnumArray(array_view<test_component::Signed> value) const
    {
        check_hresult(WINRT_IMPL_SHIM(test_component::IClass)->RefEnumArray(value.size(), put_abi(value)));
    }
    template <typename D> auto consume_test_component_IClass<D>::ReturnInt32Array() const
    {
        uint32_t result_impl_size{};
        int32_t* result{};
        check_hresult(WINRT_IMPL_SHIM(test_component::IClass)->ReturnInt32Array(&result_impl_size, &result));
        return com_array<int32_t>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_test_component_IClass<D>::ReturnStringArray() const
    {
        uint32_t result_impl_size{};
        void** result{};
        check_hresult(WINRT_IMPL_SHIM(test_component::IClass)->ReturnStringArray(&result_impl_size, &result));
        return com_array<hstring>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_test_component_IClass<D>::ReturnObjectArray() const
    {
        uint32_t result_impl_size{};
        void** result{};
        check_hresult(WINRT_IMPL_SHIM(test_component::IClass)->ReturnObjectArray(&result_impl_size, &result));
        return com_array<Windows::Foundation::IInspectable>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_test_component_IClass<D>::ReturnStringableArray() const
    {
        uint32_t result_impl_size{};
        void** result{};
        check_hresult(WINRT_IMPL_SHIM(test_component::IClass)->ReturnStringableArray(&result_impl_size, &result));
        return com_array<Windows::Foundation::IStringable>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_test_component_IClass<D>::ReturnStructArray() const
    {
        uint32_t result_impl_size{};
        struct struct_test_component_Struct* result{};
        check_hresult(WINRT_IMPL_SHIM(test_component::IClass)->ReturnStructArray(&result_impl_size, &result));
        return com_array<test_component::Struct>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_test_component_IClass<D>::ReturnEnumArray() const
    {
        uint32_t result_impl_size{};
        int32_t* result{};
        check_hresult(WINRT_IMPL_SHIM(test_component::IClass)->ReturnEnumArray(&result_impl_size, &result));
        return com_array<test_component::Signed>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_test_component_IClass<D>::NoexceptVoid() const noexcept
    {
        WINRT_VERIFY_(0, WINRT_IMPL_SHIM(test_component::IClass)->NoexceptVoid());
    }
    template <typename D> auto consume_test_component_IClass<D>::NoexceptInt32() const noexcept
    {
        int32_t result;
        WINRT_VERIFY_(0, WINRT_IMPL_SHIM(test_component::IClass)->NoexceptInt32(&result));
        return result;
    }
    template <typename D> auto consume_test_component_IClass<D>::NoexceptString() const noexcept
    {
        void* result{};
        WINRT_VERIFY_(0, WINRT_IMPL_SHIM(test_component::IClass)->NoexceptString(&result));
        return hstring{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_test_component_IClass<D>::DeferrableEvent(Windows::Foundation::TypedEventHandler<test_component::Class, test_component::DeferrableEventArgs> const& handler) const
    {
        winrt::event_token token;
        check_hresult(WINRT_IMPL_SHIM(test_component::IClass)->add_DeferrableEvent(*(void**)(&handler), put_abi(token)));
        return token;
    }
    template <typename D> typename consume_test_component_IClass<D>::DeferrableEvent_revoker consume_test_component_IClass<D>::DeferrableEvent(auto_revoke_t, Windows::Foundation::TypedEventHandler<test_component::Class, test_component::DeferrableEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, DeferrableEvent_revoker>(this, DeferrableEvent(handler));
    }
    template <typename D> auto consume_test_component_IClass<D>::DeferrableEvent(winrt::event_token const& token) const noexcept
    {
        WINRT_VERIFY_(0, WINRT_IMPL_SHIM(test_component::IClass)->remove_DeferrableEvent(impl::bind_in(token)));
    }
    template <typename D> auto consume_test_component_IClass<D>::RaiseDeferrableEventAsync() const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(test_component::IClass)->RaiseDeferrableEventAsync(&operation));
        return Windows::Foundation::IAsyncOperation<int32_t>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_test_component_IClassFactory<D>::CreateInstance(param::hstring const& name) const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(test_component::IClassFactory)->CreateInstance(*(void**)(&name), &value));
        return test_component::Class{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_test_component_IClassFactory<D>::CreateInstance2(param::iterable<hstring> const& arg, int32_t dummy1) const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(test_component::IClassFactory)->CreateInstance2(*(void**)(&arg), dummy1, &value));
        return test_component::Class{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_test_component_IClassFactory<D>::CreateInstance3(param::iterable<Windows::Foundation::Collections::IKeyValuePair<hstring, hstring>> const& arg, int32_t dummy1, int32_t dummy2) const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(test_component::IClassFactory)->CreateInstance3(*(void**)(&arg), dummy1, dummy2, &value));
        return test_component::Class{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_test_component_IClassFactory<D>::CreateInstance4(param::map<hstring, hstring> const& arg, int32_t dummy1, int32_t dummy2, int32_t dummy3) const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(test_component::IClassFactory)->CreateInstance4(*(void**)(&arg), dummy1, dummy2, dummy3, &value));
        return test_component::Class{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_test_component_IClassFactory<D>::CreateInstance5(param::map_view<hstring, hstring> const& arg, int32_t dummy1, int32_t dummy2, int32_t dummy3, int32_t dummy4) const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(test_component::IClassFactory)->CreateInstance5(*(void**)(&arg), dummy1, dummy2, dummy3, dummy4, &value));
        return test_component::Class{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_test_component_IClassFactory<D>::CreateInstance6(param::vector<hstring> const& arg, int32_t dummy1, int32_t dummy2, int32_t dummy3, int32_t dummy4, int32_t dummy5) const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(test_component::IClassFactory)->CreateInstance6(*(void**)(&arg), dummy1, dummy2, dummy3, dummy4, dummy5, &value));
        return test_component::Class{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_test_component_IClassFactory<D>::CreateInstance7(param::vector_view<hstring> const& arg, int32_t dummy1, int32_t dummy2, int32_t dummy3, int32_t dummy4, int32_t dummy5, int32_t dummy6) const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(test_component::IClassFactory)->CreateInstance7(*(void**)(&arg), dummy1, dummy2, dummy3, dummy4, dummy5, dummy6, &value));
        return test_component::Class{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_test_component_IClassStatics<D>::StaticTest() const
    {
        check_hresult(WINRT_IMPL_SHIM(test_component::IClassStatics)->StaticTest());
    }
    template <typename D> auto consume_test_component_IClassStatics<D>::StaticTestReturn() const
    {
        int32_t result;
        check_hresult(WINRT_IMPL_SHIM(test_component::IClassStatics)->StaticTestReturn(&result));
        return result;
    }
    template <typename D> auto consume_test_component_IClassStatics<D>::StaticProperty() const
    {
        int32_t value;
        check_hresult(WINRT_IMPL_SHIM(test_component::IClassStatics)->get_StaticProperty(&value));
        return value;
    }
    template <typename D> auto consume_test_component_IClassStatics<D>::InIterable(param::iterable<hstring> const& value) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(test_component::IClassStatics)->InIterable(*(void**)(&value), &result));
        return hstring{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_test_component_IClassStatics<D>::InIterablePair(param::iterable<Windows::Foundation::Collections::IKeyValuePair<hstring, hstring>> const& value) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(test_component::IClassStatics)->InIterablePair(*(void**)(&value), &result));
        return hstring{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_test_component_IClassStatics<D>::InAsyncIterable(param::async_iterable<hstring> const& value) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(test_component::IClassStatics)->InAsyncIterable(*(void**)(&value), &operation));
        return Windows::Foundation::IAsyncOperation<hstring>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_test_component_IClassStatics<D>::InAsyncIterablePair(param::async_iterable<Windows::Foundation::Collections::IKeyValuePair<hstring, hstring>> const& value) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(test_component::IClassStatics)->InAsyncIterablePair(*(void**)(&value), &operation));
        return Windows::Foundation::IAsyncOperation<hstring>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_test_component_IClassStatics<D>::InMap(param::map<hstring, hstring> const& value) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(test_component::IClassStatics)->InMap(*(void**)(&value), &result));
        return hstring{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_test_component_IClassStatics<D>::InMapView(param::map_view<hstring, hstring> const& value) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(test_component::IClassStatics)->InMapView(*(void**)(&value), &result));
        return hstring{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_test_component_IClassStatics<D>::InAsyncMapView(param::async_map_view<hstring, hstring> const& value) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(test_component::IClassStatics)->InAsyncMapView(*(void**)(&value), &operation));
        return Windows::Foundation::IAsyncOperation<hstring>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_test_component_IClassStatics<D>::InVector(param::vector<hstring> const& value) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(test_component::IClassStatics)->InVector(*(void**)(&value), &result));
        return hstring{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_test_component_IClassStatics<D>::InVectorView(param::vector_view<hstring> const& value) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(test_component::IClassStatics)->InVectorView(*(void**)(&value), &result));
        return hstring{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_test_component_IClassStatics<D>::InAsyncVectorView(param::async_vector_view<hstring> const& value) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(test_component::IClassStatics)->InAsyncVectorView(*(void**)(&value), &operation));
        return Windows::Foundation::IAsyncOperation<hstring>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_test_component_IDeferrableEventArgs<D>::GetDeferral() const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(test_component::IDeferrableEventArgs)->GetDeferral(&result));
        return Windows::Foundation::Deferral{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_test_component_IDeferrableEventArgs<D>::IncrementCounter() const
    {
        check_hresult(WINRT_IMPL_SHIM(test_component::IDeferrableEventArgs)->IncrementCounter());
    }
    template <typename D> auto consume_test_component_ISimple<D>::Method() const
    {
        check_hresult(WINRT_IMPL_SHIM(test_component::ISimple)->Method());
    }
    template <typename D> auto consume_test_component_ISimple<D>::Reference(Windows::Foundation::DateTime const& value) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(test_component::ISimple)->Reference(impl::bind_in(value), &result));
        return Windows::Foundation::IReference<int32_t>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_test_component_ISimple<D>::Operation(Windows::Foundation::DateTime const& value) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(test_component::ISimple)->Operation(impl::bind_in(value), &operation));
        return Windows::Foundation::IAsyncOperation<int32_t>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_test_component_ISimple<D>::Action(Windows::Foundation::DateTime const& value) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(test_component::ISimple)->Action(impl::bind_in(value), &operation));
        return Windows::Foundation::IAsyncAction{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_test_component_ISimple<D>::Object(Windows::Foundation::DateTime const& value) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(test_component::ISimple)->Object(impl::bind_in(value), &result));
        return Windows::Foundation::IInspectable{ result, take_ownership_from_abi };
    }
    template <typename D>
    struct produce<D, test_component::IClass> : produce_base<D, test_component::IClass>
    {
        int32_t __stdcall Fail(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Fail(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall InInt32(int32_t value, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<hstring>(this->shim().InInt32(value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall InString(void* value, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<hstring>(this->shim().InString(*reinterpret_cast<hstring const*>(&value)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall InObject(void* value, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<hstring>(this->shim().InObject(*reinterpret_cast<Windows::Foundation::IInspectable const*>(&value)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall InStringable(void* value, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<hstring>(this->shim().InStringable(*reinterpret_cast<Windows::Foundation::IStringable const*>(&value)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall InStruct(struct struct_test_component_Struct value, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<hstring>(this->shim().InStruct(*reinterpret_cast<test_component::Struct const*>(&value)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall InStructRef(struct struct_test_component_Struct const& value, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<hstring>(this->shim().InStructRef(*reinterpret_cast<test_component::Struct const*>(&value)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall InEnum(int32_t value, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<hstring>(this->shim().InEnum(*reinterpret_cast<test_component::Signed const*>(&value)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall OutInt32(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().OutInt32(*value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall OutString(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            this->shim().OutString(*reinterpret_cast<hstring*>(value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall OutObject(void** value) noexcept final try
        {
            if (value) *value = nullptr;
            Windows::Foundation::IInspectable winrt_impl_value;
            typename D::abi_guard guard(this->shim());
            this->shim().OutObject(winrt_impl_value);
                if (value) *value = detach_abi(winrt_impl_value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall OutStringable(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            this->shim().OutStringable(*reinterpret_cast<Windows::Foundation::IStringable*>(value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall OutStruct(struct struct_test_component_Struct* value) noexcept final try
        {
            zero_abi<test_component::Struct>(value);
            typename D::abi_guard guard(this->shim());
            this->shim().OutStruct(*reinterpret_cast<test_component::Struct*>(value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall OutEnum(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().OutEnum(*reinterpret_cast<test_component::Signed*>(value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ReturnInt32(int32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<int32_t>(this->shim().ReturnInt32());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ReturnString(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<hstring>(this->shim().ReturnString());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ReturnObject(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<Windows::Foundation::IInspectable>(this->shim().ReturnObject());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ReturnStringable(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<Windows::Foundation::IStringable>(this->shim().ReturnStringable());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ReturnStruct(struct struct_test_component_Struct* result) noexcept final try
        {
            zero_abi<test_component::Struct>(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<test_component::Struct>(this->shim().ReturnStruct());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ReturnEnum(int32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<test_component::Signed>(this->shim().ReturnEnum());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall InInt32Array(uint32_t __valueSize, int32_t* value, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<hstring>(this->shim().InInt32Array(array_view<int32_t const>(reinterpret_cast<int32_t const *>(value), reinterpret_cast<int32_t const *>(value) + __valueSize)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall InStringArray(uint32_t __valueSize, void** value, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<hstring>(this->shim().InStringArray(array_view<hstring const>(reinterpret_cast<hstring const *>(value), reinterpret_cast<hstring const *>(value) + __valueSize)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall InObjectArray(uint32_t __valueSize, void** value, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<hstring>(this->shim().InObjectArray(array_view<Windows::Foundation::IInspectable const>(reinterpret_cast<Windows::Foundation::IInspectable const *>(value), reinterpret_cast<Windows::Foundation::IInspectable const *>(value) + __valueSize)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall InStringableArray(uint32_t __valueSize, void** value, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<hstring>(this->shim().InStringableArray(array_view<Windows::Foundation::IStringable const>(reinterpret_cast<Windows::Foundation::IStringable const *>(value), reinterpret_cast<Windows::Foundation::IStringable const *>(value) + __valueSize)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall InStructArray(uint32_t __valueSize, struct struct_test_component_Struct* value, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<hstring>(this->shim().InStructArray(array_view<test_component::Struct const>(reinterpret_cast<test_component::Struct const *>(value), reinterpret_cast<test_component::Struct const *>(value) + __valueSize)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall InEnumArray(uint32_t __valueSize, int32_t* value, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<hstring>(this->shim().InEnumArray(array_view<test_component::Signed const>(reinterpret_cast<test_component::Signed const *>(value), reinterpret_cast<test_component::Signed const *>(value) + __valueSize)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall OutInt32Array(uint32_t* __valueSize, int32_t** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            this->shim().OutInt32Array(detach_abi<int32_t>(__valueSize, value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall OutStringArray(uint32_t* __valueSize, void*** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            this->shim().OutStringArray(detach_abi<hstring>(__valueSize, value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall OutObjectArray(uint32_t* __valueSize, void*** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            this->shim().OutObjectArray(detach_abi<Windows::Foundation::IInspectable>(__valueSize, value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall OutStringableArray(uint32_t* __valueSize, void*** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            this->shim().OutStringableArray(detach_abi<Windows::Foundation::IStringable>(__valueSize, value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall OutStructArray(uint32_t* __valueSize, struct struct_test_component_Struct** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            this->shim().OutStructArray(detach_abi<test_component::Struct>(__valueSize, value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall OutEnumArray(uint32_t* __valueSize, int32_t** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            this->shim().OutEnumArray(detach_abi<test_component::Signed>(__valueSize, value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall RefInt32Array(uint32_t __valueSize, int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().RefInt32Array(array_view<int32_t>(reinterpret_cast<int32_t*>(value), reinterpret_cast<int32_t*>(value) + __valueSize));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall RefStringArray(uint32_t __valueSize, void** value) noexcept final try
        {
            zero_abi<hstring>(value, __valueSize);
            typename D::abi_guard guard(this->shim());
            this->shim().RefStringArray(array_view<hstring>(reinterpret_cast<hstring*>(value), reinterpret_cast<hstring*>(value) + __valueSize));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall RefObjectArray(uint32_t __valueSize, void** value) noexcept final try
        {
            zero_abi<Windows::Foundation::IInspectable>(value, __valueSize);
            typename D::abi_guard guard(this->shim());
            this->shim().RefObjectArray(array_view<Windows::Foundation::IInspectable>(reinterpret_cast<Windows::Foundation::IInspectable*>(value), reinterpret_cast<Windows::Foundation::IInspectable*>(value) + __valueSize));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall RefStringableArray(uint32_t __valueSize, void** value) noexcept final try
        {
            zero_abi<Windows::Foundation::IStringable>(value, __valueSize);
            typename D::abi_guard guard(this->shim());
            this->shim().RefStringableArray(array_view<Windows::Foundation::IStringable>(reinterpret_cast<Windows::Foundation::IStringable*>(value), reinterpret_cast<Windows::Foundation::IStringable*>(value) + __valueSize));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall RefStructArray(uint32_t __valueSize, struct struct_test_component_Struct* value) noexcept final try
        {
            zero_abi<test_component::Struct>(value, __valueSize);
            typename D::abi_guard guard(this->shim());
            this->shim().RefStructArray(array_view<test_component::Struct>(reinterpret_cast<test_component::Struct*>(value), reinterpret_cast<test_component::Struct*>(value) + __valueSize));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall RefEnumArray(uint32_t __valueSize, int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().RefEnumArray(array_view<test_component::Signed>(reinterpret_cast<test_component::Signed*>(value), reinterpret_cast<test_component::Signed*>(value) + __valueSize));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ReturnInt32Array(uint32_t* __resultSize, int32_t** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().ReturnInt32Array());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ReturnStringArray(uint32_t* __resultSize, void*** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().ReturnStringArray());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ReturnObjectArray(uint32_t* __resultSize, void*** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().ReturnObjectArray());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ReturnStringableArray(uint32_t* __resultSize, void*** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().ReturnStringableArray());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ReturnStructArray(uint32_t* __resultSize, struct struct_test_component_Struct** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().ReturnStructArray());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ReturnEnumArray(uint32_t* __resultSize, int32_t** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().ReturnEnumArray());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall NoexceptVoid() noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().NoexceptVoid();
            return 0;
        }
        int32_t __stdcall NoexceptInt32(int32_t* result) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<int32_t>(this->shim().NoexceptInt32());
            return 0;
        }
        int32_t __stdcall NoexceptString(void** result) noexcept final
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<hstring>(this->shim().NoexceptString());
            return 0;
        }
        int32_t __stdcall add_DeferrableEvent(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().DeferrableEvent(*reinterpret_cast<Windows::Foundation::TypedEventHandler<test_component::Class, test_component::DeferrableEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_DeferrableEvent(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DeferrableEvent(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall RaiseDeferrableEventAsync(void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<Windows::Foundation::IAsyncOperation<int32_t>>(this->shim().RaiseDeferrableEventAsync());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, test_component::IClassFactory> : produce_base<D, test_component::IClassFactory>
    {
        int32_t __stdcall CreateInstance(void* name, void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<test_component::Class>(this->shim().CreateInstance(*reinterpret_cast<hstring const*>(&name)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateInstance2(void* arg, int32_t dummy1, void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<test_component::Class>(this->shim().CreateInstance2(*reinterpret_cast<Windows::Foundation::Collections::IIterable<hstring> const*>(&arg), dummy1));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateInstance3(void* arg, int32_t dummy1, int32_t dummy2, void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<test_component::Class>(this->shim().CreateInstance3(*reinterpret_cast<Windows::Foundation::Collections::IIterable<Windows::Foundation::Collections::IKeyValuePair<hstring, hstring>> const*>(&arg), dummy1, dummy2));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateInstance4(void* arg, int32_t dummy1, int32_t dummy2, int32_t dummy3, void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<test_component::Class>(this->shim().CreateInstance4(*reinterpret_cast<Windows::Foundation::Collections::IMap<hstring, hstring> const*>(&arg), dummy1, dummy2, dummy3));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateInstance5(void* arg, int32_t dummy1, int32_t dummy2, int32_t dummy3, int32_t dummy4, void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<test_component::Class>(this->shim().CreateInstance5(*reinterpret_cast<Windows::Foundation::Collections::IMapView<hstring, hstring> const*>(&arg), dummy1, dummy2, dummy3, dummy4));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateInstance6(void* arg, int32_t dummy1, int32_t dummy2, int32_t dummy3, int32_t dummy4, int32_t dummy5, void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<test_component::Class>(this->shim().CreateInstance6(*reinterpret_cast<Windows::Foundation::Collections::IVector<hstring> const*>(&arg), dummy1, dummy2, dummy3, dummy4, dummy5));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateInstance7(void* arg, int32_t dummy1, int32_t dummy2, int32_t dummy3, int32_t dummy4, int32_t dummy5, int32_t dummy6, void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<test_component::Class>(this->shim().CreateInstance7(*reinterpret_cast<Windows::Foundation::Collections::IVectorView<hstring> const*>(&arg), dummy1, dummy2, dummy3, dummy4, dummy5, dummy6));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, test_component::IClassStatics> : produce_base<D, test_component::IClassStatics>
    {
        int32_t __stdcall StaticTest() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().StaticTest();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall StaticTestReturn(int32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<int32_t>(this->shim().StaticTestReturn());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_StaticProperty(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().StaticProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall InIterable(void* value, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<hstring>(this->shim().InIterable(*reinterpret_cast<Windows::Foundation::Collections::IIterable<hstring> const*>(&value)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall InIterablePair(void* value, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<hstring>(this->shim().InIterablePair(*reinterpret_cast<Windows::Foundation::Collections::IIterable<Windows::Foundation::Collections::IKeyValuePair<hstring, hstring>> const*>(&value)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall InAsyncIterable(void* value, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<Windows::Foundation::IAsyncOperation<hstring>>(this->shim().InAsyncIterable(*reinterpret_cast<Windows::Foundation::Collections::IIterable<hstring> const*>(&value)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall InAsyncIterablePair(void* value, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<Windows::Foundation::IAsyncOperation<hstring>>(this->shim().InAsyncIterablePair(*reinterpret_cast<Windows::Foundation::Collections::IIterable<Windows::Foundation::Collections::IKeyValuePair<hstring, hstring>> const*>(&value)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall InMap(void* value, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<hstring>(this->shim().InMap(*reinterpret_cast<Windows::Foundation::Collections::IMap<hstring, hstring> const*>(&value)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall InMapView(void* value, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<hstring>(this->shim().InMapView(*reinterpret_cast<Windows::Foundation::Collections::IMapView<hstring, hstring> const*>(&value)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall InAsyncMapView(void* value, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<Windows::Foundation::IAsyncOperation<hstring>>(this->shim().InAsyncMapView(*reinterpret_cast<Windows::Foundation::Collections::IMapView<hstring, hstring> const*>(&value)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall InVector(void* value, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<hstring>(this->shim().InVector(*reinterpret_cast<Windows::Foundation::Collections::IVector<hstring> const*>(&value)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall InVectorView(void* value, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<hstring>(this->shim().InVectorView(*reinterpret_cast<Windows::Foundation::Collections::IVectorView<hstring> const*>(&value)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall InAsyncVectorView(void* value, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<Windows::Foundation::IAsyncOperation<hstring>>(this->shim().InAsyncVectorView(*reinterpret_cast<Windows::Foundation::Collections::IVectorView<hstring> const*>(&value)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, test_component::IDeferrableEventArgs> : produce_base<D, test_component::IDeferrableEventArgs>
    {
        int32_t __stdcall GetDeferral(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<Windows::Foundation::Deferral>(this->shim().GetDeferral());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall IncrementCounter() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IncrementCounter();
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, test_component::ISimple> : produce_base<D, test_component::ISimple>
    {
        int32_t __stdcall Method() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Method();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Reference(int64_t value, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<Windows::Foundation::IReference<int32_t>>(this->shim().Reference(*reinterpret_cast<Windows::Foundation::DateTime const*>(&value)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Operation(int64_t value, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<Windows::Foundation::IAsyncOperation<int32_t>>(this->shim().Operation(*reinterpret_cast<Windows::Foundation::DateTime const*>(&value)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Action(int64_t value, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<Windows::Foundation::IAsyncAction>(this->shim().Action(*reinterpret_cast<Windows::Foundation::DateTime const*>(&value)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Object(int64_t value, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<Windows::Foundation::IInspectable>(this->shim().Object(*reinterpret_cast<Windows::Foundation::DateTime const*>(&value)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
}
WINRT_EXPORT namespace winrt::test_component
{
    constexpr auto operator|(Unsigned const left, Unsigned const right) noexcept
    {
        return static_cast<Unsigned>(impl::to_underlying_type(left) | impl::to_underlying_type(right));
    }
    constexpr auto operator|=(Unsigned& left, Unsigned const right) noexcept
    {
        left = left | right;
        return left;
    }
    constexpr auto operator&(Unsigned const left, Unsigned const right) noexcept
    {
        return static_cast<Unsigned>(impl::to_underlying_type(left) & impl::to_underlying_type(right));
    }
    constexpr auto operator&=(Unsigned& left, Unsigned const right) noexcept
    {
        left = left & right;
        return left;
    }
    constexpr auto operator~(Unsigned const value) noexcept
    {
        return static_cast<Unsigned>(~impl::to_underlying_type(value));
    }
    constexpr auto operator^(Unsigned const left, Unsigned const right) noexcept
    {
        return static_cast<Unsigned>(impl::to_underlying_type(left) ^ impl::to_underlying_type(right));
    }
    constexpr auto operator^=(Unsigned& left, Unsigned const right) noexcept
    {
        left = left ^ right;
        return left;
    }
}
namespace std
{
#ifndef WINRT_LEAN_AND_MEAN
    template<> struct hash<winrt::test_component::IClass> : winrt::impl::hash_base {};
    template<> struct hash<winrt::test_component::IClassFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::test_component::IClassStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::test_component::IDeferrableEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::test_component::ISimple> : winrt::impl::hash_base {};
    template<> struct hash<winrt::test_component::Class> : winrt::impl::hash_base {};
    template<> struct hash<winrt::test_component::DeferrableEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::test_component::Simple> : winrt::impl::hash_base {};
#endif
}
#endif
