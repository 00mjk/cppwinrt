// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.3.4.5

#ifndef WINRT_test_component_Velocity_H
#define WINRT_test_component_Velocity_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.3.4.5"), "Mismatched C++/WinRT headers.");
#include "winrt/test_component.h"
#include "winrt/impl/test_component.Velocity.2.h"
namespace winrt::impl
{
    template <typename D> auto consume_test_component_Velocity_IClass1<D>::Class1_Method() const
    {
        check_hresult(WINRT_IMPL_SHIM(test_component::Velocity::IClass1)->Class1_Method());
    }
    template <typename D> auto consume_test_component_Velocity_IClass2<D>::Class2_Method() const
    {
        check_hresult(WINRT_IMPL_SHIM(test_component::Velocity::IClass2)->Class2_Method());
    }
    template <typename D> auto consume_test_component_Velocity_IClass3<D>::Class3_Method() const
    {
        check_hresult(WINRT_IMPL_SHIM(test_component::Velocity::IClass3)->Class3_Method());
    }
    template <typename D> auto consume_test_component_Velocity_IClass4<D>::Class4_Method() const
    {
        check_hresult(WINRT_IMPL_SHIM(test_component::Velocity::IClass4)->Class4_Method());
    }
    template <typename D> auto consume_test_component_Velocity_IClass4Factory<D>::CreateInstance(int32_t one) const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(test_component::Velocity::IClass4Factory)->CreateInstance(one, &value));
        return test_component::Velocity::Class4{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_test_component_Velocity_IClass4Factory2<D>::CreateInstance(int32_t one, int32_t two) const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(test_component::Velocity::IClass4Factory2)->CreateInstance(one, two, &value));
        return test_component::Velocity::Class4{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_test_component_Velocity_IClass4Statics<D>::Class4_Static1() const
    {
        check_hresult(WINRT_IMPL_SHIM(test_component::Velocity::IClass4Statics)->Class4_Static1());
    }
    template <typename D> auto consume_test_component_Velocity_IClass4Statics2<D>::Class4_Static2() const
    {
        check_hresult(WINRT_IMPL_SHIM(test_component::Velocity::IClass4Statics2)->Class4_Static2());
    }
    template <typename D> auto consume_test_component_Velocity_IInterface1<D>::IInterface1_Method() const
    {
        check_hresult(WINRT_IMPL_SHIM(test_component::Velocity::IInterface1)->IInterface1_Method());
    }
    template <typename D> auto consume_test_component_Velocity_IInterface2<D>::IInterface2_Method() const
    {
        check_hresult(WINRT_IMPL_SHIM(test_component::Velocity::IInterface2)->IInterface2_Method());
    }
    template <typename D>
    struct produce<D, test_component::Velocity::IClass1> : produce_base<D, test_component::Velocity::IClass1>
    {
        int32_t __stdcall Class1_Method() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Class1_Method();
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, test_component::Velocity::IClass2> : produce_base<D, test_component::Velocity::IClass2>
    {
        int32_t __stdcall Class2_Method() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Class2_Method();
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, test_component::Velocity::IClass3> : produce_base<D, test_component::Velocity::IClass3>
    {
        int32_t __stdcall Class3_Method() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Class3_Method();
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, test_component::Velocity::IClass4> : produce_base<D, test_component::Velocity::IClass4>
    {
        int32_t __stdcall Class4_Method() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Class4_Method();
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, test_component::Velocity::IClass4Factory> : produce_base<D, test_component::Velocity::IClass4Factory>
    {
        int32_t __stdcall CreateInstance(int32_t one, void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<test_component::Velocity::Class4>(this->shim().CreateInstance(one));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, test_component::Velocity::IClass4Factory2> : produce_base<D, test_component::Velocity::IClass4Factory2>
    {
        int32_t __stdcall CreateInstance(int32_t one, int32_t two, void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<test_component::Velocity::Class4>(this->shim().CreateInstance(one, two));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, test_component::Velocity::IClass4Statics> : produce_base<D, test_component::Velocity::IClass4Statics>
    {
        int32_t __stdcall Class4_Static1() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Class4_Static1();
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, test_component::Velocity::IClass4Statics2> : produce_base<D, test_component::Velocity::IClass4Statics2>
    {
        int32_t __stdcall Class4_Static2() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Class4_Static2();
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, test_component::Velocity::IInterface1> : produce_base<D, test_component::Velocity::IInterface1>
    {
        int32_t __stdcall IInterface1_Method() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IInterface1_Method();
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, test_component::Velocity::IInterface2> : produce_base<D, test_component::Velocity::IInterface2>
    {
        int32_t __stdcall IInterface2_Method() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IInterface2_Method();
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
}
WINRT_EXPORT namespace winrt::test_component::Velocity
{
}
namespace std
{
#ifndef WINRT_LEAN_AND_MEAN
    template<> struct hash<winrt::test_component::Velocity::IClass1> : winrt::impl::hash_base {};
    template<> struct hash<winrt::test_component::Velocity::IClass2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::test_component::Velocity::IClass3> : winrt::impl::hash_base {};
    template<> struct hash<winrt::test_component::Velocity::IClass4> : winrt::impl::hash_base {};
    template<> struct hash<winrt::test_component::Velocity::IClass4Factory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::test_component::Velocity::IClass4Factory2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::test_component::Velocity::IClass4Statics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::test_component::Velocity::IClass4Statics2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::test_component::Velocity::IInterface1> : winrt::impl::hash_base {};
    template<> struct hash<winrt::test_component::Velocity::IInterface2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::test_component::Velocity::Class1> : winrt::impl::hash_base {};
    template<> struct hash<winrt::test_component::Velocity::Class2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::test_component::Velocity::Class3> : winrt::impl::hash_base {};
    template<> struct hash<winrt::test_component::Velocity::Class4> : winrt::impl::hash_base {};
#endif
}
#endif
